pragma solidity ^0.4.24;
// Define a contract 'Supplychain'

import "../core/Ownable.sol";
import "../accessControl/CarManufacturerRole.sol";
import "../accessControl/PartManufacturerRole.sol";
import "../accessControl/DealershipRole.sol";

contract ProductManagement is Ownable, PartManufacturerRole, CarManufacturerRole, DealershipRole {

  // Define 'owner'
  address chainOwner;

  //'upc' for Universal Product Code of part (UPC) - Unique for product
  uint  upc;

  // 'sku' for Stock Keeping Unit of part (SKU) - Same for a company
  uint  sku;

  // 'vin' for Vehicle Identitification of car (VIN) - Unique for a car
  uint vin;

  // A public mapping 'items' that maps the UPC to an Item.
  mapping (uint => Part) parts;

  // A public mapping 'cars' that maps VIN to a car.
  mapping (uint => Car) cars;

  //A public mapping 'carParts' that maps the VIN of a car to an array of partIDs
  mapping (uint => uint[]) carParts;
 
  //Types of Products
  enum PartType
    {
    Wheels,      //0
    Body,        //1
    Engine,      //2
    Transmission //3
    }
  
  enum State 
    { 
    CarProcessed,  // 0
    Manufactured,   // 1
    Shipped    // 2   
    }

  enum PartState
    {
    Processed,
    Manufactured,
    Used
    }

  // State constant defaultState = State.CarProcessed;
  // PartState constant defaultState = PartState.Processed;

  struct Car {
    address ownerID;
    address manufacturer;
    string carModel;
    State carState;
    uint vin;
  }

   struct Part {
        uint sku;  // Stock Keeping Unit (SKU) - Type of product
        uint upc; // Universal Product Code (UPC), generated by the Manufacturer
        address ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 6 stages
        address partManufacturerID; // Metamask-Ethereum address of the Manufacturer
        uint partID;  // Product ID potentially a combination of upc + sku
        PartType partType;  // Product State as represented in the enum above
        PartState partState;
    }

  //Part Events
  event Processed(uint upc);
  event Manufactured(uint upc);
  //Car Events
  event CarProcessed(uint vin);
  event CarManufactured(uint vin);
  event CarShipped(uint vin);

  // Define a modifer that checks to see if msg.sender == owner of the contract
  modifier onlyOwner() {
    require(msg.sender == owner());
    _;
  }

  // Define a modifer that verifies the Caller
  modifier verifyCaller (address _address) {
    require(owner() == _address); 
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Harvested
  modifier processed(uint _upc) {
    require(parts[_upc].partState == PartState.Processed);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Processed
  modifier manufactured(uint _upc) {
    require(parts[_upc].partState == PartState.Manufactured);
    _;
  }
  
  modifier carProcessed(uint _vin) {
    require(cars[_vin].carState == State.CarProcessed);
    _;
  }


  modifier carManufactured(uint _vin) {
    require(cars[_vin].carState == State.Manufactured);
    _;
  }
  
  modifier carShipped(uint _vin) {
    require(cars[_vin].carState == State.Shipped);
    _;
  }

 

  constructor() public payable {
    // owner = msg.sender;
    sku = 1;
    upc = 1;
    vin = 1;
  }

  // Define a function 'kill' if required
  function kill() public {
    if (msg.sender == chainOwner) {
      selfdestruct(chainOwner);
    }
  }


function processPart(uint _upc, address _partManufacturerID, uint _partType) public
    onlyOwner()  {
      
    //  addPartManufacturer(_partManufacturerID);
      //transferOwnership(_partManufacturerID); //change ownership (Need to refactor)

    // Add the new part as part of Processed
      Part memory newItem;
        newItem.upc = _upc;
        newItem.sku = sku;
        newItem.partID = sku + _upc;
        newItem.ownerID = _partManufacturerID;
        newItem.partManufacturerID = _partManufacturerID;
        newItem.partState = PartState.Processed;
        newItem.partType = PartType(_partType);

    parts[_upc] = newItem;
    // Increment sku
    sku = sku + 1;
    // Emit the appropriate event
    emit Processed(_upc);

  }

  // Define a function 'processtItem' that allows a farmer to mark an item 'Processed'
  function manufacturePart(uint _upc) public 
  // Call modifier to verify caller of this function
  onlyOwner()
  onlyPartManufacturer()
  verifyCaller(parts[_upc].ownerID)
  // Call modifier to check if upc has passed previous supply chain stage
  processed(_upc)
  {
    // Update the appropriate fields
      parts[_upc].partState = PartState.Manufactured;
    // Emit the appropriate event
      emit Manufactured(_upc);
  }

  function processCar( address _carManufacturerID, string _model ) public
    onlyPartManufacturer()
    {
      addCarManufacturer(_carManufacturerID);
       
      Car memory newCar;
        newCar.vin = vin;
        newCar.manufacturer = _carManufacturerID;
        newCar.ownerID = _carManufacturerID;
        newCar.carModel = _model;
        newCar.carState = State.CarProcessed;

    cars[vin] = newCar;
    emit CarProcessed(vin);

    }

  

  function manufactureCar( uint _wheelsUpc, uint _engineUpc, uint _transmissionUpc, uint _bodyUpc) public 
  onlyCarManufacturer()
  carProcessed(vin)
  { 
    // TODO 
    // Add require statements to check whethere parts are of correct part type
    // require(parts[_wheelsUpc].partType==uint (PartType.Wheels)) etc etc
    uint[4] memory partsOfCar;
    partsOfCar[0] = _wheelsUpc;
    parts[_wheelsUpc].partState = PartState.Used;
    partsOfCar[1] = _engineUpc;
    parts[_engineUpc].partState = PartState.Used;
    partsOfCar[0] = _transmissionUpc;
    parts[_transmissionUpc].partState = PartState.Used;
    partsOfCar[0] = _bodyUpc;
    parts[_bodyUpc].partState = PartState.Used;
    // Add parts to car parts mapping 
    carParts[vin] = partsOfCar;
    // Update the appropriate fields
    cars[vin].carState = State.Manufactured;
    // Emit the appropriate event
    emit CarManufactured(vin);
    vin = vin + 1;
  }
 
  function shipCar(uint _vin, address _dealershipID) public
    onlyCarManufacturer()
    carManufactured(_vin)
    {
        addDealership(_dealershipID);
        // Update the appropriate fields
        cars[_vin].ownerID = _dealershipID;
        cars[_vin].carState = State.Shipped;

        // Emit the appropriate event
        emit CarShipped(_vin);
    }


  function fetchPart(uint _upc) public view returns 
  (
  uint    itemSKU,
  uint    itemUPC,
  address ownerID,
  address partManufacturerID,
  uint partID,
  PartType partType,
  PartState partState
  ) 
  {
  // Assign values to the 8 parameters
    itemSKU = parts[_upc].sku;
    itemUPC = parts[_upc].upc;
    ownerID = parts[_upc].ownerID;
    partManufacturerID = parts[_upc].partManufacturerID;
    partID = parts[_upc].partID;
    partType = parts[_upc].partType;
    partState = parts[_upc].partState;
    
  return 
  (
  itemSKU,
  itemUPC,
  ownerID,
  partManufacturerID,
  partID,
  partType,
  partState
  );
  }

 
  function fetchCar(uint _vin) public view returns 
  (
  address ownerID,
  address manufacturer,
  uint vin,
  string carModel,
  State carState
  ) 
    {
    // Assign values to the 9 parameters
  ownerID = cars[_vin].ownerID;
  vin = _vin;
  manufacturer = cars[_vin].manufacturer;
  carModel = cars[_vin].carModel;
  carState = cars[_vin].carState;

  return 
  (
        ownerID,
        manufacturer,
        vin,
        carModel,
        carState
        );
  }
}